#' Enhancer Set Enrichment Analysis (ESEA) using fgsea
#'
#' Performs enhancer set enrichment analysis (ESEA) on differential enhancer expression (DEE) results using the fgsea package.
#'
#' @param weight A named numeric vector of weights.
#' @param compare.list A list of enhancer sets (or pathways) to compare. Each element should be a vector of enhancer identifiers.
#' @param minSize Integer. Minimum number of enhancers required for a set to be considered (default is 100).
#' @param nPermSimple Integer. The number of permutations to perform in the FGSEA algorithm (default is 10000).
#'
#' @return A data frame with FGSEA results that includes columns for the normalized enrichment score (NES), p-value,
#'   q-value, a signed q-value (calculated as the sign of NES times -log10(q-value)), enrichment score (ES),
#'   the number of more extreme permutations, the size of the enhancer set, and the leading edge.
#'
#' @details
#' The function first creates a named weight vector using the sign of the DEE statistic multiplied by the negative log10 of the p-value.
#' FGSEA is then performed using the \code{fgseaMultilevel} function from the fgsea package. The results are reformatted,
#' with columns renamed, and a signed q-value is computed. Finally, the results are ordered by the signed q-value in descending order.
#'
#' @import fgsea
#'
#' @export
ESEA_fast <- function(weight, compare.list, minSize = 100, nPermSimple = 10000) {
  # Run the fgseaMultilevel algorithm using the provided enhancer sets and weight vector
  fgsea_results <- fgsea::fgseaMultilevel(pathways = compare.list, stats = weight, minSize = minSize,
                                          scoreType = "std", eps = 0, nPermSimple = nPermSimple)
  # Rename columns to more meaningful names
  colnames(fgsea_results) <- c("Compare.List", "pValue", "qValue", "ES", "NES", "nMoreExtreme", "size", "leadingEdge")
  # Compute a signed q-value: sign(NES) multiplied by -log10(qValue)
  fgsea_results$signed_qValue <- sign(fgsea_results$NES) * -log10(fgsea_results$qValue)
  # Select and order columns, then sort the results by qValue
  fgsea_results <- fgsea_results[, c("Compare.List", "NES", "pValue", "qValue", "signed_qValue", "ES",
                                     "nMoreExtreme", "size", "leadingEdge")]
  fgsea_results <- fgsea_results[order(fgsea_results$qValue), ]
  return(fgsea_results)
}


#' Plot Enhancer Set Enrichment
#'
#' Generates an enrichment plot for a specified enhancer set using DEE results.
#'
#' @param DEE_result Output from ENSEMBLE.DEE containing differential enhancer expression results.
#'   It must include the columns \code{stat}, \code{pvalue}, and \code{GHid}.
#' @param compare.list A list of enhancer sets. Each element should be a vector of enhancer identifiers.
#' @param set_name A character string specifying the name (or index) of the enhancer set in \code{compare.list} to plot.
#'
#' @return A plot generated by \code{plotEnrichment} from the fgsea package.
#'
#' @details
#' This function computes a weight vector using the sign of the DEE statistic multiplied by the negative log10 of the p-value.
#' The weight vector is then normalized using a custom min-max normalization function defined within the function.
#' Finally, the normalized weights and the selected enhancer set are passed to \code{plotEnrichment} to create the enrichment plot.
#'
#' @import fgsea
#'
#' @export
plot_enhancer_set_enrichment <- function(DEE_result,compare.list,set_name){
  weight <- setNames(sign(DEE_result$stat) * -(log10(DEE_result$pvalue)), DEE_result$GHid)
  weight_normalized <- (weight - min(weight)) / (max(weight) - min(weight))
  fgsea::plotEnrichment(compare.list[[set_name]], weight_normalized)
}

#' Draw Network from Enhancer Set Enrichment Analysis Results
#'
#' Constructs and plots a network based on enhancer set enrichment analysis (ESEA) results.
#'
#' @param ESEA.results A data frame containing ESEA results. It must include the columns:
#'   \code{NES} (normalized enrichment score), \code{GHid} (enhancer identifiers), \code{pvalue},
#'   \code{Compare.List}, and \code{leadingEdge}. Additional columns (e.g., for significance) may be present.
#' @param threshold Numeric. Cosine similarity threshold for including edges in the network (default is 0.1).
#' @param node.size Numeric. Base multiplier for node size, which is further scaled by the absolute NES value (default is 20).
#' @param line.thickness Numeric. Factor to scale edge thickness (default is 10).
#' @param font.size Numeric. Font size for node labels in the network plot (default is 10).
#' @param wrap.string.width Numeric. Maximum width (in characters) for wrapping node labels (default is 10).
#' @param FirstCharacterUpperCase Logical. If \code{TRUE}, converts node labels to title case (default is \code{FALSE}).
#'
#' @return The network plot generated by \code{igraph::plot}.
#'
#' @details
#' The function first classifies each enhancer set as "Up" or "Down" based on its NES value.
#' It then constructs a binary membership matrix from the \code{leadingEdge} lists,
#' calculates cosine similarity between enhancer sets, and converts the similarity matrix to a links data frame using
#' \code{otuSummary::matrixConvert}. Links with similarity values below the specified threshold are filtered out.
#'
#' A nodes data frame is created using the NES values to scale node sizes and the classification to set colors.
#' Finally, the network is constructed and plotted using functions from the igraph package.
#'
#' @importFrom igraph graph_from_data_frame layout.fruchterman.reingold V E
#' @importFrom stringr str_wrap str_to_title
#' @importFrom otuSummary matrixConvert
#' @export
draw.network.ORA<-function(ESEA.results, threshold=0.1,node.size=20,line.thickness=10,font.size=1,wrap.string.width=10,FirstCharacterUpperCase=F){
  ESEA.results$Type <- ifelse(ESEA.results$NES > 0, "Up", "Down")
  leadingEdgeLists <- ESEA.results$leadingEdge
  names(leadingEdgeLists) <- ESEA.results$Compare.List
  allEhancers <- unique(unlist(leadingEdgeLists))
  nSets <- length(leadingEdgeLists)
  nEnhancers <- length(allEhancers)
  binaryMat <- matrix(
    0,
    nrow = nSets,
    ncol = nEnhancers,
    dimnames = list(names(leadingEdgeLists), allEhancers)
  )
  for (i in seq_len(nSets)) {
    enhancer_set_name <- names(leadingEdgeLists)[i]
    presentEnahcners <- leadingEdgeLists[[i]]
    binaryMat[enhancer_set_name, presentEnahcners] <- 1
  }
  # Cosine similarity
  dotMat <- binaryMat %*% t(binaryMat)
  norms <- sqrt(rowSums(binaryMat))
  denom <- outer(norms, norms, FUN = "*")
  cosineMat <- dotMat / denom
  cosineMat[is.na(cosineMat)] <- 0
  links <- otuSummary::matrixConvert(cosineMat, colname = c("from", "to", "similarity"))
  links <- links[links$similarity>threshold,]
  nodes <- data.frame(id=row.names(cosineMat),size=node.size*abs(as.numeric(ESEA.results$NES[match(row.names(cosineMat),ESEA.results$Compare.List)])),type=ESEA.results$Type[match(row.names(cosineMat),ESEA.results$Compare.List)],stringsAsFactors = F)
  net <- igraph::graph_from_data_frame(d=links, vertices=nodes, directed=F)
  colrs <- c("deepskyblue","tomato1")
  igraph::V(net)$color <- colrs[as.factor(igraph::V(net)$type)]
  igraph::V(net)$size <- igraph::V(net)$size
  igraph::V(net)$label <- names(igraph::V(net))
  igraph::V(net)$label <- stringr::str_wrap(igraph::V(net)$label,wrap.string.width)
  if(FirstCharacterUpperCase==T) igraph::V(net)$label <- stringr::str_to_title(igraph::V(net)$label)
  igraph::E(net)$width <- igraph::E(net)$similarity*line.thickness
  igraph::E(net)$arrow.size <-0
  igraph::E(net)$color <- 'cornsilk2'
  network=plot(net,vertex.label.color="black",vertex.label.cex = font.size,vertex.label.family="Times", vertex.label.font=2,vertex.label.degree = 20,vertex.frame.color="white",asp=0.5,layout=igraph::layout.fruchterman.reingold(net, niter=10000))
  return(network)}

#' Disambiguate Set Enrichment Analysis (SEA) Results
#'
#' Filters and disambiguates set enrichment analysis results by comparing overlapping
#' pathways in the initial GSEA selection. The function removes elements from each pathway that
#' are shared with other pathways, computes disambiguation q-values using \code{ESEA_fast}, and
#' then filters out pathways based on a q-value cutoff.
#'
#' @param GSEA.select A data frame containing the initial GSEA (or ESEA) selection results. It must
#'   include a column named \code{Compare.List} with pathway names.
#' @param weight A numeric vector of weights (e.g., computed from DE.weights) where
#'   names correspond to enhancer identifiers.
#' @param compare.list A named list of enhancer sets. The names should correspond to set names,
#'   and each element should be a vector of enhancer identifiers.
#' @param qValue.cut Numeric. The q-value cutoff threshold (default is 0.5) above which pathways will be filtered out.
#' @param minSize Integer. The minimum size of enhancer sets to consider in \code{ESEA_fast} (default is 10).
#' @param nPermSimple Integer. Number of permutations for \code{ESEA_fast} (default is 10000).
#'
#' @return A list with the following components:
#' \describe{
#'   \item{pathway.filtered}{A data frame of filtered pathways after disambiguation.}
#'   \item{pathway.todel}{A character vector of pathway names that were removed.}
#'   \item{disambiguate.matrix}{A matrix of disambiguation q-values used in the filtering process.}
#' }
#'
#' @details
#' The function compares each pair of pathways from \code{GSEA.select} by removing elements in one pathway
#' that appear in another. It then uses the custom function \code{ESEA_fast} to compute q-values on these modified
#' enhancer sets. A disambiguation matrix is constructed from the q-values, and pathways with q-values above
#' \code{qValue.cut} are flagged. Finally, the function filters out pathways according to these flags.
#'
#' @note This function depends on the custom function \code{ESEA_fast} being available in the package.
#'
#' @export
disambiguation.SEA<-function(GSEA.select,weight,compare.list,qValue.cut=0.5,minSize=10,nPermSimple = 10000){
  topPathway=GSEA.select$Compare.List
  if (any(!(topPathway %in% names(compare.list)))) stop("compare.list does not contain all top sets")
  topPathway.list=compare.list[topPathway]
  topPathway.del=list()
  for (i in 1:length(topPathway.list)){
    pathwayx=topPathway.list[[i]]
    for (j in 1:length(topPathway.list)){
      pathwayy=topPathway.list[[j]]
      if (i==j){
        next
      }
      list=list(a=pathwayx[which(!pathwayx %in% pathwayy)]) #remove elements in pathway y from pathway x
      names(list)=c(paste(names(topPathway.list)[i],":",names(topPathway.list)[j],sep=""))
      topPathway.del=c(topPathway.del,list)
    }
  }
  #GSEA.del<-CSEA2(target.score=weight,compare.list=topPathway.del,p.cut=2,minsize=5,transformNegWeight=transformNegWeight)
  GSEA.del<-ESEA_fast(weight,topPathway.del,minSize=minSize,nPermSimple = nPermSimple)
  tmp.bin <- matrix(0, nrow = length(topPathway), ncol = length(topPathway))
  dimnames(tmp.bin) <- list(topPathway, topPathway)
  ij=which(tmp.bin==0, arr.ind = T)
  for (k in 1:nrow(ij)){
    delname=paste(rownames(tmp.bin)[ij[k,"row"]],colnames(tmp.bin)[ij[k,"col"]],sep=":")
    if (delname %in% GSEA.del$Compare.List){
      tmp.bin[ij[k,"row"],ij[k,"col"]]=as.numeric(GSEA.del$qValue[GSEA.del$Compare.List==delname])
    }else{
      tmp.bin[ij[k,"row"],ij[k,"col"]]=1
    }
  }
  index=which(tmp.bin>qValue.cut,arr.ind = TRUE)
  index=as.data.frame(index)
  index$qValue=apply(index,1,function(x) tmp.bin[x["row"],x["col"]])
  index=index[order(index$qValue,decreasing=T),] # priorize removal of less significant detected pathways after removing pathway col from pathway row
  remove=c()
  for (x in 1:nrow(index)){
    rowname=rownames(tmp.bin)[index[x,"row"]]
    colname=colnames(tmp.bin)[index[x,"col"]]
    if (rowname==colname | rowname %in% remove |colname %in% remove ){
      next
    }
    remove=c(remove,rowname)
  }
  filter.result=GSEA.select[which(!GSEA.select$Compare.List %in% remove),]
  filter.result <- filter.result[order(filter.result$qValue), ]
  #rownames(filter.result)=1:nrow(filter.result)
  return(list(pathway.filtered=filter.result,pathway.todel=remove,disambiguate.matrix=tmp.bin))
}

#' Plot SEA Results with ggplot2 and ggrepel
#'
#' Generates a scatter plot of SEA (Set Enrichment Analysis) results using ggplot2 and ggrepel.
#'
#' @param ESEA_results A data frame or data.table containing SEA results. Must include at least the columns:
#'   \code{Compare.List}, \code{NES}, and \code{pValue}.
#' @param compare.list A named list of enhancer sets where each element is a vector of gene identifiers.
#'   The names in this list must correspond to the values in \code{ESEA_results$Compare.List}.
#' @param counts A numeric matrix of counts, where rows represent genes and columns represent samples.
#'   Row names should correspond to gene identifiers.
#'
#' @return A ggplot2 object is generated that visualizes the SEA results. Points are sized by the pathway
#'   detection rate and their transparency is determined by the negative log10 of the p-value. The top 3
#'   and bottom 3 pathways (by NES) are labeled.
#'
#' @details
#' The function first computes the gene detection rate as the fraction of samples with counts greater than 1.
#' Then, for each pathway in \code{ESEA_results}, it computes the average detection rate over the genes that are present
#' both in the pathway (from \code{compare.list}) and in the \code{counts} matrix. The results are ordered by NES,
#' and a scatter plot is created where the x-axis represents the ordered pathways and the y-axis represents the NES.
#' Selected pathways (top 3 and bottom 3) are labeled using \code{geom_text_repel} for clarity.
#'
#' @import ggplot2
#' @import ggrepel
#'
#' @export
plot_SEA_results <- function(ESEA_results,compare.list,counts){
  gene_detection_rates <- rowSums(counts > 1) / ncol(counts)
  ESEA_results$set_detection_rate <- sapply(ESEA_results$Compare.List, function(pathway) {
    pathway_genes <- compare.list[[pathway]]
    existing_genes <- pathway_genes[pathway_genes %in% rownames(counts)]
    if(length(existing_genes) == 0) {
      return(0)}
    pathway_detection_rates <- gene_detection_rates[existing_genes]
    return(mean(pathway_detection_rates, na.rm = TRUE))
  })
  ESEA_results <- ESEA_results[order(ESEA_results$NES, decreasing = TRUE), ]
  ESEA_results$Compare.List <- factor(ESEA_results$Compare.List, ESEA_results$Compare.List)
  ESEA_results$xlab <- 1:nrow(ESEA_results)
  y_min <- floor(min(ESEA_results$NES))
  y_max <- ceiling(max(ESEA_results$NES))
  top_pathways <- head(as.character(ESEA_results$Compare.List), 3)  # Top 3 pathways with highest NES
  bottom_pathways <- tail(as.character(ESEA_results$Compare.List ), 3)  # Bottom 3 pathways with lowest NES
  label <- c(top_pathways, bottom_pathways)
  data_label <- ESEA_results[ESEA_results$Compare.List %in% label, ]
  data_label$col <- rep(c("#D55E00", "#0072B2", "#E69F00", "#009E73"), length.out = nrow(data_label))

  fill_color <- "#0000ff80"# Using blue with transparency as in reference code

  # Draw the basic scatter plot with improved colors
  p <- ggplot(data = ESEA_results, aes(x = xlab, y = NES)) +
    # Use gradient colors and transparency to enhance visual effect
    geom_point(aes(size = set_detection_rate, alpha = -log10(pValue)),
               shape = 21, stroke = 0.7,
               fill = fill_color, colour = "black") +
    # Use better size range similar to reference code
    scale_size_continuous(range = c(0.2, 8), name = "Detection rate (%)") +
    # Increased transparency range for better visual contrast
    scale_alpha_continuous(range = c(0.1, 0.9), name = "Significance\n(-log10 p-value)") +
    # Add title and labels - using English as requested
    labs(
      x = "Sets",
      y = "Normalized Enrichment Score (NES)"
    ) +
    # Use classic theme and increase font size
    theme_classic(base_size = 15) +
    # Adjust axes
    scale_x_continuous(breaks = seq(0, 50, by = 10), labels = seq(0, 50, by = 10)) +
    # Dynamic Y-axis scaling based on pre-calculated limits
    scale_y_continuous(
      breaks = seq(y_min, y_max, by = 1),
      labels = seq(y_min, y_max, by = 1),
      limits = c(y_min, y_max),
      expand = c(0.1, 0.1)  # Add a bit of padding
    ) +
    # Customize legend
    guides(
      size = guide_legend(title = "Detection rate (%)", order = 1),
      alpha = guide_legend(title = "Significance\n(-log10 p-value)", order = 2)
    ) +
    # Beautify theme
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 12, hjust = 0.5, color = "gray40"),
      axis.line = element_line(color = "black", linewidth = 0.6),  # Bold axis lines
      axis.text = element_text(face = "bold"),               # Bold axis text
      axis.title = element_text(size = 14, face = "bold"),   # Set axis title
      legend.title = element_text(face = "bold"),            # Bold legend title
      legend.position = "right",                             # Place legend on the right
      legend.box = "vertical",                               # Vertical legend arrangement
      panel.grid = element_blank(),                          # Remove all grid lines
      panel.background = element_rect(fill = "white")        # Ensure white background
    )
  p_final <- p +
    geom_text_repel(data = data_label,
                    aes(x = xlab, y = NES, label = Compare.List),
                    size = 3,
                    color = data_label$col,  # Using the custom colors defined above
                    force = 20,                # Label repulsion force (increased as in reference)
                    point.padding = 0.5,       # Minimum distance between labels and points
                    min.segment.length = 0,    # Minimum guide line length
                    hjust = 1.2,               # Horizontal alignment (from reference code)
                    segment.color = "grey20",  # Guide line color
                    segment.size = 0.3,        # Guide line thickness (as in reference)
                    segment.alpha = 0.8,       # Guide line transparency
                    nudge_y = -0.1)
  print(p_final)
}



#' Link GSEA and ESEA results using Fisher overlaps
#'
#' Connects the top enhancer sets from ESEA with the most prominent pathways from GSEA
#' by leveraging Fisher overlap results. The function filters each input, constructs a
#' bipartite adjacency matrix, and optionally generates a publication-ready network plot.
#'
#' @param ESEA_results Data frame with enhancer-set level enrichment results. Must include
#'   \code{Compare.List} and either \code{qValue} or \code{signed_qValue}.
#' @param GSEA_results Data frame with pathway level enrichment results. Must include
#'   \code{Compare.List} and \code{NES}.
#' @param fisher_results Data frame containing Fisher overlap results with columns
#'   \code{enh_set}, \code{gene_set}, and \code{p_adj}.
#' @param top_n_ESEA Integer indicating how many enhancer sets (ordered by \code{qValue})
#'   to retain. Use \code{NULL} to keep all after filtering.
#' @param top_n_GSEA Integer indicating how many pathways (ordered by absolute \code{NES})
#'   to retain. Use \code{NULL} to keep all.
#' @param signed_qValue_cutoff Optional numeric threshold applied on \code{abs(signed_qValue)}
#'   before ranking by \code{qValue}.
#' @param fisher_padj_cutoff Numeric threshold applied to \code{p_adj} before constructing the
#'   matrix (default \code{0.1}).
#' @param fdr_cutoff Numeric edge-level FDR cutoff applied after matrix construction (default \code{1e-3}).
#' @param edge_width_range Numeric vector of length two controlling edge thickness in the plot.
#' @param left_size_range Numeric vector of length two controlling the size range for GSEA nodes.
#' @param right_node_size Numeric scalar controlling the size of enhancer-set nodes.
#' @param label_nudge Horizontal offset applied to node labels.
#' @param label_size Size for node labels.
#' @param edge_alpha Alpha level for edges in the plot.
#' @param edge_color Edge colour used in the plot.
#' @param left_colors Named vector with colours for negative/positive NES nodes.
#' @param title Optional plot title.
#' @param subtitle Optional plot subtitle. Placeholders like `%s` are replaced with the FDR cutoff.
#'
#' @return A list with the following elements:
#' \describe{
#'   \item{fisher_matrix}{Numeric matrix used to build the network (rows = enhancer sets, columns = pathways).}
#'   \item{edges}{Data frame with edges that pass the FDR cutoff.}
#'   \item{nodes}{Data frame with node metadata and plotting coordinates.}
#'   \item{selected_ESEA}{Filtered enhancer-set results used in the network.}
#'   \item{selected_GSEA}{Filtered pathway results used in the network.}
#'   \item{plot}{A \code{ggplot2} object (or \code{NULL} when no edges pass the cutoff).}
#' }
#'
#' @examples
#' \dontrun{
#' result <- link_ESEA_GSEA_results(ESEA_results_selected_unique,
#'                                  GSEA_results_selected_unique,
#'                                  fisher_res)
#' print(result$plot)
#' }
#'
#' @export
link_ESEA_GSEA_results <- function(ESEA_results,
                                   GSEA_results,
                                   fisher_results,
                                   top_n_ESEA = 10,
                                   top_n_GSEA = 15,
                                   signed_qValue_cutoff = NULL,
                                   fisher_padj_cutoff = 0.1,
                                   fdr_cutoff = 1e-3,
                                   edge_width_range = c(0.6, 3.2),
                                   left_size_range = c(4, 12),
                                   right_node_size = 6,
                                   label_nudge = 0.03,
                                   label_size = 3,
                                   edge_alpha = 0.35,
                                   edge_color = "grey82",
                                   left_colors = c(neg = "#1F77B4", pos = "#D62728"),
                                   title = "Bipartite network of significant enrichments",
                                   subtitle = "Edges shown for FDR \u2264 %s") {
  if (!is.data.frame(ESEA_results)) stop("ESEA_results must be a data frame.")
  if (!is.data.frame(GSEA_results)) stop("GSEA_results must be a data frame.")
  if (!is.data.frame(fisher_results)) stop("fisher_results must be a data frame.")

  if (!"Compare.List" %in% names(ESEA_results)) stop("ESEA_results must contain a 'Compare.List' column.")
  if (!("qValue" %in% names(ESEA_results) || "signed_qValue" %in% names(ESEA_results))) {
    stop("ESEA_results must contain either a 'qValue' or a 'signed_qValue' column.")
  }
  if (!"Compare.List" %in% names(GSEA_results)) stop("GSEA_results must contain a 'Compare.List' column.")
  if (!"NES" %in% names(GSEA_results)) stop("GSEA_results must contain an 'NES' column.")
  required_fisher_cols <- c("enh_set", "gene_set", "p_adj")
  if (any(!required_fisher_cols %in% names(fisher_results))) {
    stop("fisher_results must contain the columns: 'enh_set', 'gene_set', and 'p_adj'.")
  }
  if (!is.null(signed_qValue_cutoff) && !"signed_qValue" %in% names(ESEA_results)) {
    stop("signed_qValue_cutoff provided but 'signed_qValue' column missing in ESEA_results.")
  }
  if (!is.null(top_n_ESEA) && (!is.numeric(top_n_ESEA) || length(top_n_ESEA) != 1 || top_n_ESEA <= 0)) {
    stop("top_n_ESEA must be a positive numeric scalar or NULL.")
  }
  if (!is.null(top_n_GSEA) && (!is.numeric(top_n_GSEA) || length(top_n_GSEA) != 1 || top_n_GSEA <= 0)) {
    stop("top_n_GSEA must be a positive numeric scalar or NULL.")
  }
  if (!is.numeric(fisher_padj_cutoff) || length(fisher_padj_cutoff) != 1 || fisher_padj_cutoff <= 0 || fisher_padj_cutoff > 1) {
    stop("fisher_padj_cutoff must be a numeric scalar in (0, 1].")
  }
  if (!is.numeric(fdr_cutoff) || length(fdr_cutoff) != 1 || fdr_cutoff <= 0 || fdr_cutoff > 1) {
    stop("fdr_cutoff must be a numeric scalar in (0, 1].")
  }

  rescale_range <- function(x, to) {
    if (!length(x)) return(rep(mean(to), length.out = length(x)))
    finite_x <- x[is.finite(x)]
    if (!length(finite_x)) return(rep(mean(to), length.out = length(x)))
    rng <- range(finite_x)
    if (diff(rng) == 0) return(rep(mean(to), length.out = length(x)))
    ((x - rng[1]) / diff(rng)) * (to[2] - to[1]) + to[1]
  }

  esea_df <- ESEA_results
  esea_df <- esea_df[!is.na(esea_df$Compare.List), , drop = FALSE]
  esea_df$Compare.List <- as.character(esea_df$Compare.List)
  if (!is.null(signed_qValue_cutoff)) {
    esea_df <- esea_df[abs(esea_df$signed_qValue) >= signed_qValue_cutoff, , drop = FALSE]
  }
  if (nrow(esea_df) == 0) stop("No enhancer sets left after filtering ESEA_results.")
  if ("qValue" %in% names(esea_df)) {
    esea_df <- esea_df[order(esea_df$qValue, -abs(if ("signed_qValue" %in% names(esea_df)) esea_df$signed_qValue else esea_df$qValue)), , drop = FALSE]
  } else {
    esea_df <- esea_df[order(-abs(esea_df$signed_qValue)), , drop = FALSE]
  }
  if (!is.null(top_n_ESEA) && nrow(esea_df) > top_n_ESEA) {
    esea_df <- esea_df[seq_len(top_n_ESEA), , drop = FALSE]
  }
  enhancer_sets <- unique(esea_df$Compare.List)

  gsea_df <- GSEA_results
  gsea_df <- gsea_df[!is.na(gsea_df$Compare.List), , drop = FALSE]
  gsea_df$Compare.List <- as.character(gsea_df$Compare.List)
  gsea_df$NES <- as.numeric(gsea_df$NES)
  gsea_df <- gsea_df[order(-abs(gsea_df$NES)), , drop = FALSE]
  if (!is.null(top_n_GSEA) && nrow(gsea_df) > top_n_GSEA) {
    gsea_df <- gsea_df[seq_len(top_n_GSEA), , drop = FALSE]
  }
  gene_sets <- unique(gsea_df$Compare.List)

  fisher_df <- fisher_results
  fisher_df <- fisher_df[is.finite(fisher_df$p_adj) & fisher_df$p_adj <= fisher_padj_cutoff, , drop = FALSE]
  if (nrow(fisher_df) == 0) stop("No Fisher overlaps pass the specified padj cutoff.")
  fisher_df$enh_set <- as.character(fisher_df$enh_set)
  fisher_df$gene_set <- as.character(fisher_df$gene_set)
  fisher_df$p_adj <- pmax(fisher_df$p_adj, .Machine$double.xmin)
  fisher_df$score <- -log10(fisher_df$p_adj)

  unique_enh <- sort(unique(fisher_df$enh_set))
  unique_gene <- sort(unique(fisher_df$gene_set))
  score_matrix <- matrix(0, nrow = length(unique_enh), ncol = length(unique_gene),
                         dimnames = list(unique_enh, unique_gene))
  for (i in seq_len(nrow(fisher_df))) {
    current_score <- fisher_df$score[i]
    enh <- fisher_df$enh_set[i]
    gene <- fisher_df$gene_set[i]
    if (current_score > score_matrix[enh, gene]) {
      score_matrix[enh, gene] <- current_score
    }
  }

  enh_to_keep <- intersect(rownames(score_matrix), enhancer_sets)
  gene_to_keep <- intersect(colnames(score_matrix), gene_sets)
  if (!length(enh_to_keep)) stop("No enhancer sets overlap with the Fisher results after filtering.")
  if (!length(gene_to_keep)) stop("No pathways overlap with the Fisher results after filtering.")

  fisher_matrix <- score_matrix[enh_to_keep, gene_to_keep, drop = FALSE]

  gsea_map <- stats::setNames(gsea_df$NES, gsea_df$Compare.List)

  left_nodes <- data.frame(
    name = gene_to_keep,
    NES = gsea_map[gene_to_keep],
    stringsAsFactors = FALSE
  )
  left_nodes$absNES <- abs(left_nodes$NES)
  left_nodes <- left_nodes[order(left_nodes$absNES, decreasing = TRUE), , drop = FALSE]
  left_nodes$NES_sign <- ifelse(is.na(left_nodes$NES) | left_nodes$NES < 0, "neg", "pos")
  left_nodes$size_val <- rescale_range(left_nodes$absNES, left_size_range)
  left_nodes$side <- "GSEA"

  right_nodes <- data.frame(
    name = enh_to_keep,
    stringsAsFactors = FALSE
  )
  strength <- numeric(length(enh_to_keep))
  if (nrow(fisher_matrix)) {
    strength <- rowSums(fisher_matrix[enh_to_keep, left_nodes$name, drop = FALSE], na.rm = TRUE)
  }
  right_nodes$strength <- strength
  right_nodes <- right_nodes[order(right_nodes$strength, decreasing = TRUE), , drop = FALSE]
  right_nodes$side <- "ESEA"

  fisher_matrix <- fisher_matrix[right_nodes$name, left_nodes$name, drop = FALSE]

  if (!nrow(fisher_matrix) || !ncol(fisher_matrix)) {
    stop("Filtered Fisher matrix is empty; please relax cutoffs or provide more results.")
  }
  edge_df <- data.frame(
    from = rep(colnames(fisher_matrix), each = nrow(fisher_matrix)),
    to = rep(rownames(fisher_matrix), times = ncol(fisher_matrix)),
    weight = as.numeric(fisher_matrix),
    stringsAsFactors = FALSE
  )
  edge_df <- edge_df[edge_df$weight > 0, , drop = FALSE]
  if (nrow(edge_df)) {
    score_cut <- -log10(fdr_cutoff)
    edge_df <- edge_df[edge_df$weight >= score_cut, , drop = FALSE]
  }
  edge_df$fdr <- if (nrow(edge_df)) 10^(-edge_df$weight) else numeric(0)

  left_x <- 0.25
  right_x <- 0.75
  if (nrow(left_nodes)) {
    left_nodes$x <- rep(left_x, nrow(left_nodes))
    left_nodes$y <- seq(from = nrow(left_nodes), to = 1, length.out = nrow(left_nodes))
  } else {
    left_nodes$x <- numeric(0)
    left_nodes$y <- numeric(0)
  }
  if (nrow(right_nodes)) {
    right_nodes$x <- rep(right_x, nrow(right_nodes))
    right_nodes$y <- seq(from = nrow(right_nodes), to = 1, length.out = nrow(right_nodes))
  } else {
    right_nodes$x <- numeric(0)
    right_nodes$y <- numeric(0)
  }

  nodes_combined <- rbind(
    left_nodes[, c("name", "side", "NES", "NES_sign", "size_val", "x", "y")],
    data.frame(
      name = right_nodes$name,
      side = right_nodes$side,
      NES = NA_real_,
      NES_sign = NA_character_,
      size_val = rep(right_node_size, nrow(right_nodes)),
      x = right_nodes$x,
      y = right_nodes$y,
      stringsAsFactors = FALSE
    )
  )

  plot_obj <- NULL
  if (nrow(edge_df)) {
    edge_df$x <- left_nodes$x[match(edge_df$from, left_nodes$name)]
    edge_df$y <- left_nodes$y[match(edge_df$from, left_nodes$name)]
    edge_df$xend <- right_nodes$x[match(edge_df$to, right_nodes$name)]
    edge_df$yend <- right_nodes$y[match(edge_df$to, right_nodes$name)]

    subtitle_text <- if (!is.null(subtitle)) sprintf(subtitle, format(fdr_cutoff, digits = 3, scientific = TRUE)) else NULL

    plot_obj <- ggplot2::ggplot() +
      ggplot2::geom_segment(
        data = edge_df,
        ggplot2::aes(x = x, y = y, xend = xend, yend = yend, linewidth = weight),
        colour = edge_color,
        alpha = edge_alpha,
        show.legend = TRUE
      ) +
      ggplot2::scale_linewidth_continuous(
        name = expression(-log[10]("FDR")),
        range = edge_width_range
      ) +
      ggplot2::geom_point(
        data = left_nodes,
        ggplot2::aes(x = x, y = y, fill = NES_sign, size = size_val),
        shape = 21,
        colour = "black",
        stroke = 0.35,
        show.legend = FALSE
      ) +
      ggplot2::scale_fill_manual(values = left_colors, guide = "none") +
      ggplot2::scale_size_identity(guide = "none") +
      ggplot2::geom_point(
        data = right_nodes,
        ggplot2::aes(x = x, y = y),
        shape = 24,
        size = right_node_size,
        colour = "black",
        fill = "black",
        show.legend = FALSE
      ) +
      ggplot2::geom_text(
        data = left_nodes,
        ggplot2::aes(x = x - label_nudge, y = y, label = name),
        hjust = 1,
        size = label_size
      ) +
      ggplot2::geom_text(
        data = right_nodes,
        ggplot2::aes(x = x + label_nudge, y = y, label = name),
        hjust = 0,
        size = label_size
      ) +
      ggplot2::scale_x_continuous(
        limits = c(left_x - 2 * label_nudge, right_x + 2 * label_nudge),
        expand = ggplot2::expansion(mult = c(0, 0))
      ) +
      ggplot2::scale_y_continuous(expand = ggplot2::expansion(mult = c(0.05, 0.05))) +
      ggplot2::theme_void() +
      ggplot2::theme(
        legend.position = "right",
        plot.margin = ggplot2::margin(10, 60, 10, 60, unit = "pt")
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle_text
      )
  } else {
    warning("No edges pass the specified FDR cutoff; returning metadata without a plot.")
  }

  list(
    fisher_matrix = fisher_matrix,
    edges = edge_df,
    nodes = nodes_combined,
    selected_ESEA = esea_df[esea_df$Compare.List %in% rownames(fisher_matrix), , drop = FALSE],
    selected_GSEA = gsea_df[gsea_df$Compare.List %in% colnames(fisher_matrix), , drop = FALSE],
    plot = plot_obj
  )
}

#' Select High-Confidence Enhancer-Set Helpers from ESEA Results
#'
#' Filters ESEA output to retain helper enhancer sets that satisfy a q-value cutoff,
#' an optional elbow heuristic, and an optional connectivity requirement derived from
#' leading-edge overlaps.
#'
#' @param esea_result Data frame with ESEA output. Must include the columns specified
#'   in \code{qcol}, \code{id_col}, and \code{le_col}.
#' @param qcut Numeric. Maximum q-value to retain (default \code{0.05}).
#' @param use_elbow Logical. If \code{TRUE}, retain only helpers up to the elbow point
#'   of the ordered \code{qcol} values (default \code{TRUE}).
#' @param use_connect Logical. If \code{TRUE}, compute cosine-based connectivity among
#'   leading-edge sets and filter by \code{k_mad} (default \code{TRUE}).
#' @param k_mad Numeric multiplier on the MAD of connectivity scores that defines the
#'   minimum connectivity to retain (default \code{0}).
#' @param qcol Character. Column name storing q-values (default \code{"qValue"}).
#' @param id_col Character. Column holding enhancer-set identifiers
#'   (default \code{"Compare.List"}).
#' @param le_col Character. Column with comma-separated leading-edge enhancers
#'   (default \code{"leadingEdge"}).
#'
#' @return A filtered data frame ordered by \code{qcol} (and connectivity when applicable)
#'   and containing a \code{connectivity} column summarising helper similarity.
#'
#' @export
select_enhancer_set_helpers <- function(esea_result,
                                        qcut = 0.05,
                                        use_elbow = TRUE,
                                        use_connect = TRUE,
                                        k_mad = 0,
                                        qcol = "qValue",
                                        id_col = "Compare.List",
                                        le_col = "leadingEdge") {
  if (!is.data.frame(esea_result)) stop("`esea_result` must be a data frame.")
  req <- c(qcol, id_col, le_col)
  missing_cols <- req[!req %in% names(esea_result)]
  if (length(missing_cols)) {
    stop("`esea_result` must contain columns: ", paste(missing_cols, collapse = ", "))
  }

  add_empty_conn <- function(df) {
    if (!"connectivity" %in% names(df)) df$connectivity <- numeric(nrow(df))
    if (nrow(df)) df$connectivity[] <- NA_real_
    df
  }

  qv <- suppressWarnings(as.numeric(esea_result[[qcol]]))
  keep_q <- is.finite(qv) & !is.na(qv) & (qv < qcut)
  esea1 <- esea_result[keep_q, , drop = FALSE]
  if (nrow(esea1) == 0) {
    return(add_empty_conn(esea_result[0, , drop = FALSE]))
  }
  esea1 <- esea1[order(esea1[[qcol]], decreasing = FALSE), , drop = FALSE]

  esea2 <- esea1
  if (use_elbow) {
    q1 <- esea1[[qcol]]
    q_safe <- pmax(q1, .Machine$double.xmin)
    neglog10q <- -log10(q_safe)
    n <- length(q1)
    rank <- seq_len(n)
    x01 <- if (n > 1) (rank - 1) / (n - 1) else rep(0, n)
    rng <- max(neglog10q) - min(neglog10q)
    y01 <- if (rng > 0) (neglog10q - min(neglog10q)) / rng else rep(0, n)
    yflip <- 1 - y01
    gap <- yflip - x01
    k_idx <- which.max(gap)
    q_elbow <- q1[k_idx]
    esea2 <- esea1[q1 <= q_elbow, , drop = FALSE]
    if (nrow(esea2) == 0) {
      return(add_empty_conn(esea2))
    }
  }

  if (!use_connect) {
    esea2$connectivity <- NA_real_
    return(esea2)
  }

  le_raw <- as.character(esea2[[le_col]])
  le_list <- lapply(le_raw, function(s) {
    if (is.na(s) || !nzchar(s)) return(character(0))
    x <- unlist(strsplit(s, ","))
    x <- gsub("^\\s+|\\s+$", "", x)
    unique(x[nzchar(x)])
  })
  row_ids <- as.character(esea2[[id_col]])
  names(le_list) <- row_ids

  genes <- sort(unique(unlist(le_list)))
  if (!length(genes)) {
    esea2$connectivity <- NA_real_
    return(esea2)
  }

  g_idx <- structure(seq_along(genes), names = genes)
  ii <- integer(0)
  jj <- integer(0)
  for (r in seq_along(le_list)) {
    gs <- le_list[[r]]
    if (length(gs)) {
      cols <- unname(g_idx[gs])
      ii <- c(ii, rep.int(r, length(cols)))
      jj <- c(jj, cols)
    }
  }
  LE <- Matrix::sparseMatrix(
    i = ii,
    j = jj,
    x = 1L,
    dims = c(length(le_list), length(genes)),
    dimnames = list(row_ids, genes)
  )

  rs <- sqrt(Matrix::rowSums(LE^2))
  rs[rs == 0] <- 1
  LEu <- Matrix::Diagonal(x = 1 / rs) %*% LE

  S_cos <- as.matrix(Matrix::tcrossprod(LEu))
  dimnames(S_cos) <- list(row_ids, row_ids)
  diag(S_cos) <- 0

  conn_by_row <- rowSums(S_cos, na.rm = TRUE)
  names(conn_by_row) <- row_ids
  esea2$connectivity <- as.numeric(conn_by_row)

  med_conn <- stats::median(esea2$connectivity, na.rm = TRUE)
  mad_raw <- stats::mad(esea2$connectivity, constant = 1, na.rm = TRUE)
  conn_cut <- med_conn + k_mad * mad_raw

  esea3 <- esea2[is.finite(esea2$connectivity) & (esea2$connectivity >= conn_cut), , drop = FALSE]
  esea3 <- esea3[order(esea3[[qcol]], -esea3$connectivity), , drop = FALSE]
  esea3
}

#' Annotate Helper Enhancer Sets with Top HALLMARK Labels
#'
#' Adds a \code{top_hallmark} column to a helper table by selecting the most
#' significantly enriched MSigDB Hallmark pathway per helper via Fisher overlaps.
#'
#' @param es_helpers Data frame returned by \code{select_enhancer_set_helpers}.
#' @param associations_path File path to a CSV containing enhancer-to-gene associations
#'   with at least \code{GHid} and \code{symbol} columns.
#' @param hallmarks_path File path to a GMT file (or compatible format) that can be
#'   read with \code{\link{read_concepts}}.
#' @param minGSSize Minimum Hallmark gene-set size to consider (default \code{10}).
#' @param maxGSSize Maximum Hallmark gene-set size to consider (default \code{500}).
#' @param fdr_alpha Per-helper FDR cutoff applied to BH-adjusted Fisher p-values
#'   (default \code{0.1}).
#' @param no_sig_label Text inserted when no Hallmark passes the cutoff
#'   (default \code{"no significant HALLMARK annotation"}).
#'
#' @return \code{es_helpers} with an extra column \code{top_hallmark}.
#'
#' @export
annotate_helpers_with_hallmark_top1 <- function(
    es_helpers,
    associations_path,
    hallmarks_path,
    minGSSize = 10,
    maxGSSize = 500,
    fdr_alpha = 0.1,
    no_sig_label = "no significant HALLMARK annotation") {

  if (!is.data.frame(es_helpers)) stop("`es_helpers` must be a data frame.")
  required_helper_cols <- c("Compare.List", "leadingEdge")
  miss_helper <- setdiff(required_helper_cols, names(es_helpers))
  if (length(miss_helper)) {
    stop("`es_helpers` must contain columns: ", paste(miss_helper, collapse = ", "))
  }

  if (!file.exists(associations_path)) {
    stop("`associations_path` does not exist: ", associations_path)
  }
  if (!file.exists(hallmarks_path)) {
    stop("`hallmarks_path` does not exist: ", hallmarks_path)
  }

  associations <- utils::read.csv(associations_path, stringsAsFactors = FALSE, check.names = FALSE)
  required_assoc_cols <- c("GHid", "symbol")
  miss_assoc <- setdiff(required_assoc_cols, names(associations))
  if (length(miss_assoc)) {
    stop("Association file missing columns: ", paste(miss_assoc, collapse = ", "))
  }

  hallmarks <- read_concepts(hallmarks_path, min = 0)
  if (!length(hallmarks)) stop("No hallmark gene sets were loaded.")

  gene_univ <- sort(unique(as.character(associations$symbol)))
  gene_univ <- gene_univ[nzchar(gene_univ)]
  if (!length(gene_univ)) stop("Association file contains no valid symbols.")
  N <- length(gene_univ)

  hm_sets <- lapply(hallmarks, function(v) intersect(unique(as.character(v)), gene_univ))
  hm_sizes <- vapply(hm_sets, length, integer(1))
  keep <- which(hm_sizes >= minGSSize & hm_sizes <= maxGSSize)
  hm_sets <- hm_sets[keep]
  hm_sizes <- hm_sizes[keep]
  if (!length(hm_sets)) stop("No hallmark sets pass the provided size filters.")

  split_trim <- function(s) {
    x <- unlist(strsplit(as.character(s), ","))
    x <- gsub("^\\s+|\\s+$", "", x)
    unique(x[nzchar(x)])
  }

  enh2genes <- split(as.character(associations$symbol), as.character(associations$GHid))
  top_labels <- rep_len(no_sig_label, nrow(es_helpers))

  for (r in seq_len(nrow(es_helpers))) {
    enh <- split_trim(es_helpers$leadingEdge[r])
    if (!length(enh)) next

    genes <- unique(unlist(enh2genes[intersect(enh, names(enh2genes))], use.names = FALSE))
    genes <- intersect(genes, gene_univ)
    b <- length(genes)
    if (b == 0L) next

    a <- hm_sizes
    k <- vapply(hm_sets, function(gs) length(intersect(gs, genes)), integer(1))
    pvals <- ifelse(a > 0, stats::phyper(pmax(k - 1, 0), a, N - a, b, lower.tail = FALSE), 1)
    qvals <- stats::p.adjust(pvals, method = "BH")

    ord <- order(qvals, pvals)
    top_idx <- ord[1]
    top_q <- qvals[top_idx]

    top_labels[r] <- if (!is.finite(top_q) || top_q >= fdr_alpha) no_sig_label else names(hm_sets)[top_idx]
  }

  es_helpers$top_hallmark <- top_labels
  es_helpers
}
